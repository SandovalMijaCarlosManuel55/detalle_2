<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GJ 504b - Planeta Rosa</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #0a0015 0%, #1a0030 50%, #0f001a 100%);
            font-family: 'Arial', sans-serif;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 24px;
            color: #ffaaee;
        }
        p {
            margin: 5px 0;
            font-size: 14px;
            line-height: 1.5;
        }
        .label {
            color: #ffccff;
            font-weight: bold;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff88dd;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 136, 221, 0.3);
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="container"></div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, planet, atmosphere, stars;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;

        function init() {
            // Escena
            scene = new THREE.Scene();

            // Cámara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // Estrellas de fondo
            createStars();

            // Planeta principal
            const geometry = new THREE.SphereGeometry(2, 64, 64);
            
            // Material del planeta con textura procedural
            const planetMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        vUv = uv;
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    // Ruido para las nubes
                    float noise(vec3 p) {
                        return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
                    }
                    
                    float fbm(vec3 p) {
                        float value = 0.0;
                        float amplitude = 0.5;
                        for(int i = 0; i < 5; i++) {
                            value += amplitude * noise(p);
                            p *= 2.0;
                            amplitude *= 0.5;
                        }
                        return value;
                    }
                    
                    void main() {
                        // Colores base del planeta rosa
                        vec3 color1 = vec3(0.95, 0.4, 0.7);  // Rosa brillante
                        vec3 color2 = vec3(0.7, 0.2, 0.5);   // Magenta oscuro
                        vec3 color3 = vec3(0.85, 0.5, 0.65); // Rosa medio
                        
                        // Crear bandas y turbulencias como Neptuno
                        vec3 pos = vPosition + vec3(time * 0.05, 0.0, 0.0);
                        float pattern = fbm(pos * 2.0 + vec3(0.0, vUv.y * 8.0, 0.0));
                        float bands = sin(vUv.y * 20.0 + pattern * 3.0) * 0.5 + 0.5;
                        
                        // Mezclar colores
                        vec3 color = mix(color1, color2, bands);
                        color = mix(color, color3, pattern * 0.3);
                        
                        // Iluminación
                        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                        float diff = max(dot(vNormal, lightDir), 0.0);
                        color *= (0.6 + diff * 0.4);
                        
                        // Brillo interno (calor residual)
                        float glow = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
                        color += vec3(0.3, 0.1, 0.2) * glow * 0.5;
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `
            });
            
            planet = new THREE.Mesh(geometry, planetMaterial);
            scene.add(planet);

            // Atmósfera brillante
            const atmosphereGeometry = new THREE.SphereGeometry(2.15, 64, 64);
            const atmosphereMaterial = new THREE.ShaderMaterial({
                transparent: true,
                side: THREE.BackSide,
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    void main() {
                        float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                        gl_FragColor = vec4(1.0, 0.4, 0.8, 1.0) * intensity * 0.6;
                    }
                `
            });
            
            atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            scene.add(atmosphere);

            // Luz ambiente
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // Luz direccional
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);

            // Luz rosa para el brillo
            const pinkLight = new THREE.PointLight(0xff66bb, 1, 100);
            pinkLight.position.set(0, 0, 3);
            scene.add(pinkLight);

            // Eventos
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('wheel', onWheel);
            window.addEventListener('resize', onWindowResize);
        }

        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = [];
            
            for(let i = 0; i < 3000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starVertices.push(x, y, z);
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2,
                transparent: true,
                opacity: 0.8
            });
            
            stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        function onMouseMove(event) {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            targetRotationY = mouseX * 0.5;
            targetRotationX = mouseY * 0.5;
        }

        function onWheel(event) {
            camera.position.z += event.deltaY * 0.005;
            camera.position.z = Math.max(3, Math.min(10, camera.position.z));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Rotación suave del planeta
            planet.rotation.y += 0.001;
            atmosphere.rotation.y += 0.0008;
            
            // Seguimiento del mouse
            planet.rotation.x += (targetRotationX - planet.rotation.x) * 0.05;
            planet.rotation.y += (targetRotationY - planet.rotation.y) * 0.05;
            atmosphere.rotation.x = planet.rotation.x;
            
            // Rotación lenta de las estrellas
            stars.rotation.y += 0.0001;
            
            // Actualizar shader del tiempo
            planet.material.uniforms.time.value += 0.01;

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>